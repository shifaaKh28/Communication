
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>  // POSIX operating system API access (e.g., close(), sleep())
#include <sys/socket.h>// Definitions of structures needed for sockets
#include <netinet/in.h> // Internet address family for stockade_in structure
#include <arpa/inet.h>// Functions for manipulating IP addresses
#include <netinet/tcp.h>// TCP-specific socket options and constants
#include <time.h> // Functions for manipulating time
#include <stddef.h>

#define BUFFER_SIZE 8192 // Define the buffer size for receiving data

/**
 * Generates random data of the specified size.
 * 
 * @param size The size of the random data to generate.
 * @return A pointer to the buffer containing the generated random data.
 */
char *create_random_data(unsigned int size){
    char *buffer=NULL;// Pointer to the buffer for storing the random data
    if (size == 0){
        return NULL;
    }
    // Allocate memory for the buffer to store the random data
    buffer = (char *)calloc(size, sizeof(char));

     // Error checking: If memory allocation fails, return NULL
      if (buffer == NULL){
        return NULL;
    }    
    /*
    initializes the random number generator with a seed value based on the current time, 
    ensuring that the random numbers generated by rand() are different each time the program is executed.
    */
    srand(time(NULL));

     // Generate random data and store it in the buffer
     for (unsigned int i = 0; i < size; i++){
        *(buffer + i) = ((unsigned int)rand() % 256);  // Assign random values in the range [0, 255]
     }
     return buffer;   

}
int main(int argc, char *argv[]){
     char buffer[BUFFER_SIZE] = {0};  // Buffer to store received data
     
       // Create a server address.
    struct sockaddr_in server;
    memset(&server, 0, sizeof(server));  // Initialize server address structure with zeros

     // Generate some random data.
     unsigned int size = 2097152; //2*1024^2= 2MB
      char *message=create_random_data(size);// Generate random data to send
      if (message == NULL)  // Check if random data generation failed
    {
        perror("generating data has failed");
        return -1;  // Return -1 to indicate failure
    }

    // Create a socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);  // Create a TCP socket
    if (sock == -1)  // Check if socket creation failed
    {
        perror("socket(2) failed");
        return -1;  // Return -1 to indicate failure
    }

    // Need to fix the TCP_CONGESTION

    if (strcmp(argv[6], "cubic") == 0)  // Check if TCP congestion control algorithm is "cubic"
    {
        if (setsockopt(sock, IPPROTO_TCP, TCP_CONGESTION, "cubic", strlen("cubic")) != 0) 
        {
            perror("setsockopt() failed");
            return -1;  // Return -1 to indicate failure
        }
    }
     else if (strcmp(argv[6], "reno") == 0)  // Check if TCP congestion control algorithm is "reno"
    {
        if (setsockopt(sock, IPPROTO_TCP, TCP_CONGESTION, "reno", strlen("reno")) != 0) 
        {
            perror("setsockopt() failed");
            return -1;  // Return -1 to indicate failure
        }
    }
     else  // If TCP congestion control algorithm is neither "reno" nor "cubic"
    {
        return -1;  // Return -1 to indicate failure
    }


     // Set the server address.
     server.sin_family = AF_INET;  // Set address family to IPv4  
     server.sin_port = htons(atoi(argv[4]));  // Set port number from command-line argument

      // Connect to the server.
    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)  // Connect to server
    {
        perror("connecting() failed");
        close(sock);
        return -1;  // Return -1 to indicate failure
    } 
    printf("connected to server...\n");

// Initialize the option variable to 'yes' to enter the loop at least once
    char option = 'yes';
    while (option == 'yes')
    {
        // Send the  data
        int bytes_sent = 0;
        // Continue sending until all data is sent
        while (bytes_sent < size)
        {
            // Send data to the server
            int  bytes_sent_now = send(sock, message + bytes_sent, size - bytes_sent, 0);
            if ( bytes_sent_now < 0) // Check if sending failed
            {

                perror("send(2)");
                close(sock);
                return 1;
            }
            bytes_sent +=  bytes_sent_now;// Update the total bytes sent counter
            printf("Sent %d bytes\n", bytes_sent);
        }
          // Send the "Finish" message to the server indicating that the data transfer is complete
        char* finishMessage = "Finish\n";
        send(sock, finishMessage, strlen(finishMessage), 0);

 // Prompt the user whether they want to send the message again
        printf("Do you want to send the message again? (yes/no): ");
        scanf(" %c", &option);// Read the user's input
         getchar();
    }

   // Send the "Exit" message to the server to terminate the connection
    printf("Sending exit message to the server\n");
    char* exitMessage = "Exit\n";
    send(sock, exitMessage, strlen(exitMessage), 0);
    printf("exit message was sent\n");

    // Receive the message from the server.
    int bytes_received = recv(sock, buffer, sizeof(buffer), 0);
    if (bytes_received <= 0)// Check if receiving failed
    {
        perror("recv(2)");
        close(sock);
        return 1;
    }

// Ensure that the buffer is null-terminated to prevent potential segmentation faults (SEGFAULTs) when using the buffer as a string.
    if (buffer[BUFFER_SIZE - 1] != '\0')
        buffer[BUFFER_SIZE- 1] = '\0';

    close(sock);// Close the socket with the server.
    fprintf(stdout, "Connection is closed.\n");
    free(message);    return 0;
}
