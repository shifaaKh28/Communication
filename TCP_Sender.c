#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>  // POSIX operating system API access (e.g., close(), sleep())
#include <sys/socket.h>// Definitions of structures needed for sockets
#include <netinet/in.h> // Internet address family for stockade_in structure
#include <arpa/inet.h>// Functions for manipulating IP addresses
#include <netinet/tcp.h>// TCP-specific socket options and constants
#include <time.h> // Functions for manipulating time
#include <stddef.h>

#define BUFFER_SIZE 8192 // Define the buffer size for receiving data

/**
 * Generates random data of the specified size.
 * 
 * @param size The size of the random data to generate.
 * @return A pointer to the buffer containing the generated random data.
 */
char *create_random_data(unsigned int size){
    char *buffer=NULL;// Pointer to the buffer for storing the random data
    if (size == 0){
        return NULL;
    }
    // Allocate memory for the buffer to store the random data
    buffer = (char *)calloc(size, sizeof(char));

     // Error checking: If memory allocation fails, return NULL
      if (buffer == NULL){
        return NULL;
    }    
    /*
    initializes the random number generator with a seed value based on the current time, 
    ensuring that the random numbers generated by rand() are different each time the program is executed.
    */
    srand(time(NULL));

     // Generate random data and store it in the buffer
     for (unsigned int i = 0; i < size; i++){
        *(buffer + i) = ((unsigned int)rand() % 256);  // Assign random values in the range [0, 255]
     }
     return buffer;   

}
int main(int argc, char *argv[]){
     char buffer[BUFFER_SIZE] = {0};  // Buffer to store received data
     
       // Create a server address.
    struct sockaddr_in server;
    memset(&server, 0, sizeof(server));  // Initialize server address structure with zeros

     // Generate some random data.
     unsigned int size = 2097152; //2*1024^2= 2MB
      char *message=create_random_data(size);// Generate random data to send
      if (message == NULL)  // Check if random data generation failed
    {
        perror("generating data has failed");
        return -1;  // Return -1 to indicate failure
    }

    // Create a socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);  // Create a TCP socket
    if (sock == -1)  // Check if socket creation failed
    {
        perror("socket(2) failed");
        return -1;  // Return -1 to indicate failure
    }

    // Need to fix the TCP_CONGESTION

    if (strcmp(argv[6], "cubic") == 0)  // Check if TCP congestion control algorithm is "cubic"
    {
        if (setsockopt(sock, IPPROTO_TCP, TCP_CONGESTION, "cubic", strlen("cubic")) != 0) 
        {
            perror("setsockopt() failed");
            return -1;  // Return -1 to indicate failure
        }
    }
     else if (strcmp(argv[6], "reno") == 0)  // Check if TCP congestion control algorithm is "reno"
    {
        if (setsockopt(sock, IPPROTO_TCP, TCP_CONGESTION, "reno", strlen("reno")) != 0) 
        {
            perror("setsockopt() failed");
            return -1;  // Return -1 to indicate failure
        }
    }
     else  // If TCP congestion control algorithm is neither "reno" nor "cubic"
    {
        return -1;  // Return -1 to indicate failure
    }


     // Set the server address.
     server.sin_family = AF_INET;  // Set address family to IPv4  
     server.sin_port = htons(atoi(argv[4]));  // Set port number from command-line argument

      // Connect to the server.
    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)  // Connect to server
    {
        perror("connecting() failed");
        close(sock);
        return -1;  // Return -1 to indicate failure
    } 
     printf("Connecting to Reciever...\n");

     char option = 'yes';  // Initialize option to 'yes' to enter the loop at least once
     while (option == 'yes') {
    // Send the data.
    int totalBytesSent = 0;  // Total bytes sent counter

    do {
        // Send remaining data to server
        int bytesSent = send(sock, message + totalBytesSent, size - totalBytesSent, 0);
        if (bytesSent < 0) {  // Check if sending failed
            perror("send(2)");
            close(sock);
            return 1;  // Return 1 to indicate failure
        }
         totalBytesSent += bytesSent;  // Update total bytes sent counter
    } while (totalBytesSent < size);  // Continue sending until all data is sent

    printf("the data sent successfully\n");

     // Send finish message to the server
    char* finish= "Finish\n";
    send(sock, finish, strlen(finish), 0);

    printf("Do you want to send the file again? (yes/no): ");
    scanf(" %c", &option);  // Prompt user to send message again
}
// Send exit message to the server
printf("Sending exit message to the server\n");
char* mssg = "exit\n";
send(sock, mssg, strlen(mssg), 0);
printf("exit message sent\n");

// Receive a message from the server.
int bytes_received = recv(sock, buffer, sizeof(buffer), 0);  // Receive data from server
if (bytes_received <= 0) {  // Check if receiving failed
    perror("recv(2)");
    close(sock);
    return 1;  // Return 1 to indicate failure
}

// Ensure that the buffer is null-terminated to prevent potential segmentation faults (SEGFAULTs) when using the buffer as a string.
if (buffer[BUFFER_SIZE - 1] != '\0')  // Ensure null-termination of buffer
    buffer[BUFFER_SIZE - 1] = '\0';

// Close the socket with the server.
close(sock);  // Close socket connection

fprintf(stdout, "Connection closed!\n");

free(message);  // Free dynamically allocated memory for message
return 0; 
}


